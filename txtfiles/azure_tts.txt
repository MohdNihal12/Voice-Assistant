# app/azure_tts.py - Azure Cognitive Services Text-to-Speech with Config Integration
import os
import asyncio
import threading
from typing import Optional, Dict, Any
from dotenv import load_dotenv
import pyaudio
import wave
import tempfile
import io
import time
import logging

# Azure Cognitive Services SDK
try:
    import azure.cognitiveservices.speech as speechsdk
    AZURE_AVAILABLE = True
except ImportError:
    AZURE_AVAILABLE = False
    logging.warning("Azure Speech SDK not installed. Install with: pip install azure-cognitiveservices-speech")

# Import config manager
from app.config_manager import config_manager

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class AzureTTS:
    """
    Azure Cognitive Services Text-to-Speech with robust audio interruption control and config integration
    """

    def __init__(self,
                 voice_name: str = None,
                 language: str = None,
                 speech_synthesis_output_format: str = None):

        # Get config values
        config = config_manager.get_config()

        # Use config values with fallbacks
        self.voice_name = voice_name or config.tts.azure_voice_name
        self.language = language or config.tts.azure_language
        self.output_format = speech_synthesis_output_format or config.tts.azure_output_format
        self.timeout = config.tts.timeout
        self.speech_config = None
        self.synthesizer = None

        # Audio playback control with thread-safe operations
        self._is_playing = False
        self._stop_playback = False
        self._current_stream = None
        self._pyaudio = None
        self._playback_lock = threading.RLock()
        self._playback_thread = None

        # Statistics
        self.stats = {
            'tts_requests': 0,
            'audio_generated': 0,
            'playback_completed': 0,
            'playback_interrupted': 0,
            'errors': 0,
            'total_audio_duration': 0.0
        }

        self._initialize_client_and_audio()

    def _initialize_client_and_audio(self):
        """Initialize the Azure Speech SDK and PyAudio"""
        try:
            # Check if TTS is enabled
            config = config_manager.get_config()
            if not config.features.enable_tts:
                logger.info("ï¿½ TTS disabled in configuration")
                return

            if not AZURE_AVAILABLE:
                logger.error("L Azure Speech SDK not available")
                raise ImportError("Azure Speech SDK not installed")

            # Get Azure credentials from environment
            azure_key = os.getenv("AZURE_SPEECH_KEY")
            azure_region = os.getenv("AZURE_SPEECH_REGION")

            if not azure_key or not azure_region:
                logger.error("AZURE_SPEECH_KEY or AZURE_SPEECH_REGION not found in environment variables")
                raise ValueError("Azure credentials not found in environment variables")

            # Configure Azure Speech SDK
            self.speech_config = speechsdk.SpeechConfig(
                subscription=azure_key,
                region=azure_region
            )

            # Set voice name
            self.speech_config.speech_synthesis_voice_name = self.voice_name

            # Set output format
            format_mapping = {
                'audio-16khz-32kbitrate-mono-mp3': speechsdk.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3,
                'audio-16khz-64kbitrate-mono-mp3': speechsdk.SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3,
                'audio-16khz-128kbitrate-mono-mp3': speechsdk.SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3,
                'audio-24khz-48kbitrate-mono-mp3': speechsdk.SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3,
                'audio-24khz-96kbitrate-mono-mp3': speechsdk.SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3,
                'audio-24khz-160kbitrate-mono-mp3': speechsdk.SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3,
                'riff-16khz-16bit-mono-pcm': speechsdk.SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm,
                'riff-24khz-16bit-mono-pcm': speechsdk.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm,
            }

            if self.output_format in format_mapping:
                self.speech_config.set_speech_synthesis_output_format(format_mapping[self.output_format])
            else:
                logger.warning(f"Unknown output format: {self.output_format}, using default")

            # Create synthesizer with None audio config to get raw audio data
            # Setting audio_config=None tells the SDK to return audio data instead of playing it
            self.synthesizer = speechsdk.SpeechSynthesizer(
                speech_config=self.speech_config,
                audio_config=None
            )

            # Initialize PyAudio
            self._pyaudio = pyaudio.PyAudio()

            logger.info(f" Azure TTS initialized with PyAudio control")
            logger.info(f"ï¿½ Config: Voice: {self.voice_name}, Language: {self.language}, Format: {self.output_format}")
            logger.info(f"ï¿½ Timeout: {self.timeout}s, TTS Enabled: {config.features.enable_tts}")

        except Exception as e:
            logger.error(f"L Failed to initialize Azure TTS: {e}")
            self.speech_config = None
            self.synthesizer = None

    @property
    def is_playing(self):
        """Thread-safe access to playing state"""
        with self._playback_lock:
            return self._is_playing

    def stop_current_audio(self):
        """Force stop the currently playing audio - SYNCHRONOUS VERSION"""
        config = config_manager.get_config()
        if not config.features.enable_tts:
            logger.debug("ï¿½ TTS disabled - ignoring stop request")
            return

        with self._playback_lock:
            if self._is_playing:
                logger.info("=ï¿½ Force stopping current audio playback")
                self._stop_playback = True
                self.stats['playback_interrupted'] += 1

                # Stop the PyAudio stream immediately
                if self._current_stream:
                    try:
                        self._current_stream.stop_stream()
                        self._current_stream.close()
                        logger.debug("PyAudio stream closed")
                    except Exception as e:
                        logger.warning(f"Error closing stream: {e}")
                    finally:
                        self._current_stream = None

                self._is_playing = False

                # Wait for playback thread to finish if it exists
                if self._playback_thread and self._playback_thread.is_alive():
                    logger.debug("Waiting for playback thread to terminate...")
                    self._playback_thread.join(timeout=1.0)
                    if self._playback_thread.is_alive():
                        logger.warning("Playback thread did not terminate cleanly")

                self._playback_thread = None

        # Small delay to ensure cleanup
        time.sleep(0.05)
        logger.info(" Audio playback stopped successfully")

    async def text_to_speech(self, text: str, play_audio: bool = True, interrupt_current: bool = True) -> Optional[bytes]:
        """
        Convert text to speech with robust interruption control

        Args:
            text: Text to convert to speech
            play_audio: Whether to play the audio immediately
            interrupt_current: Whether to interrupt currently playing audio

        Returns:
            Audio data as bytes if successful, None otherwise
        """
        # Check if TTS is enabled
        config = config_manager.get_config()
        if not config.features.enable_tts:
            logger.info("ï¿½ TTS disabled - skipping audio generation")
            return None

        if not self.synthesizer:
            logger.error("Azure synthesizer not initialized")
            return None

        if not text or not text.strip():
            logger.warning("Empty text provided for TTS")
            return None

        try:
            logger.info(f"=Converting text to speech (Azure): '{text[:50]}...'")
            self.stats['tts_requests'] += 1

            # Stop current playback if requested - DO THIS FIRST
            if interrupt_current:
                await asyncio.get_event_loop().run_in_executor(None, self.stop_current_audio)

            # Generate audio data with timeout from config
            audio_data = await asyncio.wait_for(
                self._generate_audio_data(text),
                timeout=self.timeout
            )

            if audio_data:
                self.stats['audio_generated'] += 1
                if play_audio:
                    await self._play_audio_async(audio_data)

            return audio_data

        except asyncio.TimeoutError:
            logger.error(f"ï¿½ TTS generation timed out after {self.timeout} seconds")
            self.stats['errors'] += 1
            return None
        except Exception as e:
            logger.error(f"L TTS conversion failed: {e}")
            self.stats['errors'] += 1
            import traceback
            traceback.print_exc()
            return None

    async def _generate_audio_data(self, text: str) -> Optional[bytes]:
        """Generate audio data from text using Azure Speech SDK"""
        try:
            loop = asyncio.get_event_loop()

            def synthesize():
                result = self.synthesizer.speak_text_async(text).get()

                if result.reason == speechsdk.ResultReason.SynthesizingAudioCompleted:
                    logger.info(f" Azure TTS conversion successful - {len(result.audio_data)} bytes")
                    return result.audio_data
                elif result.reason == speechsdk.ResultReason.Canceled:
                    cancellation_details = result.cancellation_details
                    logger.error(f"L Speech synthesis canceled: {cancellation_details.reason}")
                    if cancellation_details.reason == speechsdk.CancellationReason.Error:
                        logger.error(f"Error details: {cancellation_details.error_details}")
                    return None
                else:
                    logger.error(f"L Unexpected result reason: {result.reason}")
                    return None

            audio_data = await loop.run_in_executor(None, synthesize)
            return audio_data

        except Exception as e:
            logger.error(f"L Audio generation failed: {e}")
            return None

    async def _play_audio_async(self, audio_data: bytes):
        """Play audio data asynchronously with interruption support"""
        if not audio_data:
            return

        # Check if TTS is enabled
        config = config_manager.get_config()
        if not config.features.enable_tts:
            logger.debug("ï¿½ TTS disabled - skipping audio playback")
            return

        try:
            logger.info("=Playing audio with interruption control...")

            # Use thread pool executor for synchronous playback
            await asyncio.get_event_loop().run_in_executor(
                None,
                lambda: self._play_audio_sync(audio_data)
            )

        except Exception as e:
            logger.error(f"L Audio playback failed: {e}")
            self.stats['errors'] += 1

    def _play_audio_sync(self, audio_data: bytes):
        """Synchronous audio playback with real-time interruption checking"""
        # Check if TTS is enabled
        config = config_manager.get_config()
        if not config.features.enable_tts:
            return

        with self._playback_lock:
            if self._stop_playback:
                logger.info("Playback aborted before starting")
                return

            self._is_playing = True
            self._stop_playback = False

        try:
            # Write audio data to temporary file
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as tmp_file:
                tmp_file.write(audio_data)
                tmp_file.flush()
                temp_filename = tmp_file.name

            # Open the WAV file
            with wave.open(temp_filename, 'rb') as wf:
                # Get audio parameters
                sample_width = wf.getsampwidth()
                channels = wf.getnchannels()
                frame_rate = wf.getframerate()
                frames_per_buffer = 1024

                # Calculate audio duration for stats
                n_frames = wf.getnframes()
                duration = n_frames / float(frame_rate)
                self.stats['total_audio_duration'] += duration

                # Open PyAudio stream
                stream = self._pyaudio.open(
                    format=self._pyaudio.get_format_from_width(sample_width),
                    channels=channels,
                    rate=frame_rate,
                    output=True,
                    frames_per_buffer=frames_per_buffer
                )

                with self._playback_lock:
                    self._current_stream = stream

                # Play audio in chunks with interruption checking
                data = wf.readframes(frames_per_buffer)
                while data and not self._stop_playback:
                    stream.write(data)
                    data = wf.readframes(frames_per_buffer)

                # Clean up stream
                stream.stop_stream()
                stream.close()

                with self._playback_lock:
                    self._current_stream = None

            # Clean up temporary file
            try:
                os.unlink(temp_filename)
            except Exception as e:
                logger.warning(f"Could not delete temp file: {e}")

            if self._stop_playback:
                logger.info("Playback was interrupted")
            else:
                logger.info(" Playback completed successfully")
                self.stats['playback_completed'] += 1

        except Exception as e:
            logger.error(f"L Audio playback error: {e}")
            self.stats['errors'] += 1
        finally:
            with self._playback_lock:
                self._is_playing = False

    async def generate_and_speak(self, llm_response: Dict[str, Any], interrupt_current: bool = True):
        """
        Generate speech from LLM response text

        Args:
            llm_response: Response dictionary from LLM
            interrupt_current: Whether to interrupt current playback
        """
        # Check if TTS is enabled
        config = config_manager.get_config()
        if not config.features.enable_tts:
            logger.debug("ï¿½ TTS disabled - skipping speech generation")
            return

        if not llm_response or not llm_response.get('success'):
            logger.warning("Invalid LLM response for TTS")
            return

        text = llm_response.get('text', '').strip()
        if not text:
            logger.warning("Empty text in LLM response")
            return

        await self.text_to_speech(text, interrupt_current=interrupt_current)

    def get_voice_info(self) -> Dict[str, Any]:
        """Get information about the current voice configuration"""
        config = config_manager.get_config()

        return {
            'provider': 'azure',
            'voice_name': self.voice_name,
            'language': self.language,
            'output_format': self.output_format,
            'timeout': self.timeout,
            'is_playing': self.is_playing,
            'client_initialized': self.synthesizer is not None,
            'pyaudio_initialized': self._pyaudio is not None,
            'tts_enabled': config.features.enable_tts,
            'config_source': 'config.json'
        }

    def get_stats(self) -> Dict[str, Any]:
        """Get TTS system statistics"""
        config = config_manager.get_config()

        stats = {
            'provider': 'azure',
            'tts_requests': self.stats['tts_requests'],
            'audio_generated': self.stats['audio_generated'],
            'playback_completed': self.stats['playback_completed'],
            'playback_interrupted': self.stats['playback_interrupted'],
            'errors': self.stats['errors'],
            'total_audio_duration': round(self.stats['total_audio_duration'], 2),
            'success_rate': f"{(self.stats['audio_generated'] / self.stats['tts_requests'] * 100) if self.stats['tts_requests'] > 0 else 0:.1f}%",
            'tts_enabled': config.features.enable_tts,
            'config': {
                'voice_name': self.voice_name,
                'language': self.language,
                'output_format': self.output_format,
                'timeout': self.timeout
            }
        }

        return stats

    async def test_connection(self) -> bool:
        """Test connection to Azure Speech Services"""
        config = config_manager.get_config()
        if not config.features.enable_tts:
            logger.info("ï¿½ TTS disabled - connection test skipped")
            return False

        if not self.synthesizer:
            return False

        try:
            # Try a simple synthesis as a connection test
            test_audio = await self._generate_audio_data("Test")
            return test_audio is not None
        except Exception as e:
            logger.warning(f"ï¿½ Azure connection test failed: {e}")
            return False

    def cleanup(self):
        """Cleanup resources - call this when shutting down"""
        config = config_manager.get_config()
        if not config.features.enable_tts:
            return

        self.stop_current_audio()
        if self._pyaudio:
            try:
                self._pyaudio.terminate()
                logger.info(" PyAudio terminated")
            except Exception as e:
                logger.warning(f"ï¿½ Error terminating PyAudio: {e}")

    def __del__(self):
        """Cleanup resources"""
        self.cleanup()


# Example usage and testing
async def main():
    """Test the Azure TTS system with configuration"""
    tts = AzureTTS()

    # Test connection
    print("Testing Azure Speech Services connection...")
    if await tts.test_connection():
        print(" Azure connection successful!")
    else:
        print("L Azure connection failed!")
        return

    # Test TTS with different texts
    test_texts = [
        "Hello! This is a test of the Azure text to speech system.",
        "How can I help you with steel and aluminum products today?",
        "We have stainless steel 304 and aluminum 5052 in stock."
    ]

    for i, text in enumerate(test_texts, 1):
        print(f"\n>ï¿½ Test {i}: '{text}'")
        audio_data = await tts.text_to_speech(text, play_audio=True, interrupt_current=True)

        if audio_data:
            print(f" TTS successful - {len(audio_data)} bytes")
        else:
            print("L TTS failed")

        # Small delay between tests
        await asyncio.sleep(1)

    # Print statistics
    print(f"\n=ï¿½ TTS Stats: {tts.get_stats()}")
    print(f" Voice Info: {tts.get_voice_info()}")

    # Cleanup
    tts.cleanup()


if __name__ == "__main__":
    asyncio.run(main())
