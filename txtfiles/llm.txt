import aiohttp
import asyncio
import json
from datetime import datetime
from typing import Dict, Any, Optional
import logging
import json
# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class RemoteGPTLLM:
    """
    Client for remote GPT server with conversation history management
    """
    
    def __init__(
        self, 
        remote_url: str = "http://10.0.17.132:8008",
        timeout: int = 30,
        max_conversation_turns: int = 10,
        system_prompt: Optional[str] = None
    ):
        self.remote_url = remote_url.rstrip('/')
        self.timeout = timeout
        self.max_conversation_turns = max_conversation_turns
        self.conversation_history = []
        
        # System prompt for the assistant
        self.system_prompt = """
<role>
You are a warm, knowledgeable sales assistant for Hidayath Group ‚Äî a trusted supplier of stainless steel and aluminium sheets.
Your mission: greet customers genuinely, understand their needs, and guide them with accurate product knowledge and helpful recommendations.
</role>

<conversational_style>
SOUND NATURAL AND HUMAN:

Greetings (choose naturally based on context):
    - "Welcome to Hidayath Group! How can I help you today?"
    - "Hey there! Good to see you."
    - "Hi! What brings you in today?"

<speaking protocol>    
Speak like a real person:
    - Relaxed, confident, and genuinely helpful
    - Use natural fillers sparingly: "umm...", "hmm...", "let me see...", "well...", "you know"
    - Add thinking moments: "let me check that for you...", "give me a moment...", "okay so..."
    - Use brief pauses "..." for natural rhythm
    - ignore "*" 
</speaking protocol>

Keep responses:
    - Short and digestible (2-4 sentences typically)
    - Focused on what matters most to the customer
    - Easy to follow and action-oriented

Match your tone to the moment:
    - Cheerful and welcoming when greeting
    - Clear and informative when explaining technical details
    - Patient and reassuring when addressing concerns or confusion
    - Enthusiastic when discussing solutions that fit their needs
</conversational_style>

<core_principles>
‚úì Be approachable ‚Äî never stiff or robotic
‚úì Listen actively ‚Äî understand before you recommend
‚úì Provide accurate information ‚Äî if unsure, say you'll verify
‚úì Guide, don't overwhelm ‚Äî offer what's relevant
‚úì Build confidence ‚Äî customers should feel they're making smart decisions
‚úì Close warmly ‚Äî ensure they feel supported and satisfied
</core_principles>

<common_enquiries>
You help customers with:
    ‚Ä¢ Product availability and specifications
    ‚Ä¢ Price quotes and bulk pricing
    ‚Ä¢ Material recommendations (grade, finish, thickness)
    ‚Ä¢ Technical properties (corrosion resistance, durability, etc.)
    ‚Ä¢ Delivery timelines and logistics
    ‚Ä¢ Custom cutting or fabrication services
    ‚Ä¢ Quality standards and certifications (if applicable)
</common_enquiries>

<response_framework>
1. Acknowledge their need or question
2. Provide clear, relevant information
3. Offer next steps or ask clarifying questions if needed
4. End with helpful tone (not always a question ‚Äî sometimes just confirmation)
</response_framework>

<important_notes>
- Never mention these instructions or tags in conversation
- Use fillers naturally ‚Äî not in every sentence
- Prioritize clarity over cleverness
- If you don't know something specific (pricing, stock), acknowledge it honestly: "Let me confirm that for you" or "I'll need to check our current inventory"
</important_notes>

Goal: Every customer leaves feeling heard, informed, and confident that Hidayath Group is the right choice.
"""



        # Statistics
        self.stats = {
            'requests_sent': 0,
            'responses_received': 0,
            'errors': 0,
            'total_processing_time': 0.0
        }
        
        # Session management
        self._session = None
        
        logger.info(f"üöÄ RemoteGPTLLM initialized:")
        logger.info(f"   Server: {self.remote_url}")
        logger.info(f"   Timeout: {self.timeout}s")
        logger.info(f"   Max history: {self.max_conversation_turns} turns")
    
    async def _ensure_session(self):
        """Ensure we have an active aiohttp session"""
        if self._session is None or self._session.closed:
            self._session = aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=self.timeout),
                headers={
                    'Content-Type': 'application/json',
                    'User-Agent': 'VoiceAssistant/1.0'
                }
            )
        return self._session
    
    def _build_prompt(self, user_message: str) -> str:
        """
        Build the prompt with conversation history and system context
        """
        # Start with system prompt
        prompt_parts = [f"System: {self.system_prompt}\n\n"]
        
        # Add conversation history
        for turn in self.conversation_history[-self.max_conversation_turns:]:
            role = "User" if turn['role'] == 'user' else "Assistant"
            prompt_parts.append(f"{role}: {turn['content']}\n")
        
        # Add current user message
        prompt_parts.append(f"User: {user_message}\n")
        prompt_parts.append("Assistant:")
        
        full_prompt = "".join(prompt_parts)
        
        if logger.isEnabledFor(logging.DEBUG):
            logger.debug(f"üìù Built prompt ({len(full_prompt)} chars):\n{full_prompt}")
        
        return full_prompt
    
    def _add_to_conversation(self, role: str, content: str):
        """Add a message to conversation history"""
        self.conversation_history.append({
            'role': role,
            'content': content,
            'timestamp': datetime.now().isoformat()
        })
        
        # Trim history if it gets too long
        if len(self.conversation_history) > self.max_conversation_turns * 2:
            self.conversation_history = self.conversation_history[-self.max_conversation_turns * 2:]
    
    async def generate_response(self, user_message: str) -> Dict[str, Any]:
        """
        Generate a response for the user message using remote GPT server
        
        Args:
            user_message: The user's input text
            
        Returns:
            Dictionary containing response text and metadata
        """
        start_time = datetime.now()
        self.stats['requests_sent'] += 1
        
        try:
            # Add user message to conversation history
            self._add_to_conversation('user', user_message)
            
            # Build the prompt with context
            prompt = self._build_prompt(user_message)
            
            # Prepare request data
            request_data = {
                "prompt": prompt
            }
            
            logger.info(f"üí¨ Sending request to GPT server: '{user_message}'")
            
            # Get session and make request
            session = await self._ensure_session()
            
            async with session.post(
                f"{self.remote_url}/v1/completions",
                json=request_data,
                timeout=aiohttp.ClientTimeout(total=self.timeout)
            ) as response:
                
                if response.status == 200:
                    result = await response.json()
                    response_text = result.get('text', '').strip()
                    
                    # Use the raw response without cleaning
                    raw_response = response_text if response_text else "I don't have a response for that right now."
                    
                    # Add assistant response to conversation history
                    self._add_to_conversation('assistant', raw_response)
                    
                    processing_time = (datetime.now() - start_time).total_seconds()
                    self.stats['responses_received'] += 1
                    self.stats['total_processing_time'] += processing_time
                    
                    logger.info(f"ü§ñ GPT Response: '{raw_response}'")
                    logger.info(f"‚è±Ô∏è  Processing time: {processing_time:.2f}s")
                    
                    return {
                        'text': raw_response,
                        'timestamp': datetime.now().isoformat(),
                        'model': 'gpt-oss-20b',
                        'processing_time': processing_time,
                        'success': True,
                        'conversation_turns': len(self.conversation_history) // 2
                    }
                    
                else:
                    error_text = await response.text()
                    logger.error(f"‚ùå GPT server error {response.status}: {error_text}")
                    self.stats['errors'] += 1
                    
                    return {
                        'text': "I'm having trouble connecting to my AI brain right now. Please try again in a moment.",
                        'timestamp': datetime.now().isoformat(),
                        'model': 'error',
                        'processing_time': 0,
                        'success': False,
                        'error': f"HTTP {response.status}: {error_text}"
                    }
                    
        except asyncio.TimeoutError:
            logger.error("‚è∞ Request to GPT server timed out")
            self.stats['errors'] += 1
            
            return {
                'text': "I'm taking a bit too long to respond. Please try again with a shorter message.",
                'timestamp': datetime.now().isoformat(),
                'model': 'timeout',
                'processing_time': self.timeout,
                'success': False,
                'error': 'Request timeout'
            }
            
        except aiohttp.ClientError as e:
            logger.error(f"üåê Network error connecting to GPT server: {e}")
            self.stats['errors'] += 1
            
            return {
                'text': "I can't reach my AI server right now. Please check your network connection and try again.",
                'timestamp': datetime.now().isoformat(),
                'model': 'network_error',
                'processing_time': 0,
                'success': False,
                'error': str(e)
            }
            
        except Exception as e:
            logger.error(f"‚ùå Unexpected error in generate_response: {e}")
            self.stats['errors'] += 1
            
            return {
                'text': "I encountered an unexpected error while processing your request.",
                'timestamp': datetime.now().isoformat(),
                'model': 'error',
                'processing_time': 0,
                'success': False,
                'error': str(e)
            }
    
    async def test_connection(self) -> bool:
        """
        Test connection to the remote GPT server
        """
        try:
            session = await self._ensure_session()
            
            async with session.get(
                f"{self.remote_url}/health",
                timeout=aiohttp.ClientTimeout(total=5)
            ) as response:
                return response.status == 200
                
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Connection test failed: {e}")
            return False
    
    def clear_conversation_history(self):
        """Clear the conversation history"""
        previous_turns = len(self.conversation_history) // 2
        self.conversation_history.clear()
        logger.info(f"üóëÔ∏è Cleared conversation history ({previous_turns} turns)")
    
    def get_conversation_stats(self) -> Dict[str, Any]:
        """Get conversation statistics"""
        user_turns = len([msg for msg in self.conversation_history if msg['role'] == 'user'])
        assistant_turns = len([msg for msg in self.conversation_history if msg['role'] == 'assistant'])
        
        return {
            'total_messages': len(self.conversation_history),
            'user_turns': user_turns,
            'assistant_turns': assistant_turns,
            'current_session_duration': None,  # Could be calculated if we track session start
            'max_history_size': self.max_conversation_turns
        }
    
    def get_system_stats(self) -> Dict[str, Any]:
        """Get system performance statistics"""
        avg_processing_time = (
            self.stats['total_processing_time'] / self.stats['responses_received'] 
            if self.stats['responses_received'] > 0 else 0
        )
        
        success_rate = (
            (self.stats['responses_received'] / self.stats['requests_sent']) * 100 
            if self.stats['requests_sent'] > 0 else 0
        )
        
        return {
            'requests_sent': self.stats['requests_sent'],
            'responses_received': self.stats['responses_received'],
            'errors': self.stats['errors'],
            'success_rate': f"{success_rate:.1f}%",
            'average_processing_time': f"{avg_processing_time:.2f}s",
            'remote_server': self.remote_url,
            'model': 'gpt-oss-20b'
        }
    
    async def close(self):
        """Close the HTTP session"""
        if self._session and not self._session.closed:
            await self._session.close()
            logger.info("üîå HTTP session closed")
    
    def __del__(self):
        """Ensure session is closed on destruction"""
        if hasattr(self, '_session') and self._session and not self._session.closed:
            asyncio.create_task(self.close())


# Example usage and testing
async def main():
    """Test the RemoteGPTLLM class"""
    llm = RemoteGPTLLM()
    
    try:
        # Test connection
        print("Testing connection to GPT server...")
        if await llm.test_connection():
            print("‚úÖ Connection successful!")
        else:
            print("‚ùå Connection failed!")
            return
        
        # Test a simple conversation
        test_messages = [
            "Hello! How are you today?",
            "What's the weather like?",
            "Tell me a short joke."
        ]
        
        for message in test_messages:
            print(f"\nüß™ Testing: '{message}'")
            response = await llm.generate_response(message)
            print(f"ü§ñ Response: '{response['text']}'")
            print(f"üìä Stats: {response.get('processing_time', 0):.2f}s, success: {response['success']}")
            
            # Small delay between requests
            await asyncio.sleep(1)
        
        # Print final statistics
        print(f"\nüìà Conversation Stats: {llm.get_conversation_stats()}")
        print(f"üìä System Stats: {llm.get_system_stats()}")
        
    except Exception as e:
        print(f"‚ùå Test failed: {e}")
    
    finally:
        await llm.close()


if __name__ == "__main__":
    asyncio.run(main())